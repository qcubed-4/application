<?php
    /**
     *
     * Part of the QCubed PHP framework.
     *
     * @license MIT
     *
     */

    namespace QCubed\Control;

    use QCubed as Q;
    use QCubed\Exception\Caller;
    use QCubed\Exception\IndexOutOfRange;
    use QCubed\Exception\InvalidCast;
    use QCubed\Html;
    use QCubed\QString;
    use QCubed\Table\CallableColumn;
    use QCubed\Table\ColumnBase;
    use QCubed\Table\IndexedColumn;
    use QCubed\Table\LinkColumn;
    use QCubed\Table\NodeColumn;
    use QCubed\Table\PropertyColumn;
    use QCubed\Table\VirtualAttributeColumn;
    use QCubed\Type;
    use Throwable;


    /**
     * Class Table
     *
     * <p>This control is used to display a simple HTML table.
     *
     * <p>The control itself will display things based off of an array of objects that gets set as the "Data Source".
     * It is particularly useful when combined with the Class::loadArrayByXXX() functions or the Class::loadAll()
     * that is generated by the CodeGen framework, or when combined with custom Class ArrayLoaders that you define
     *  yourself, but whose structure is based off of the CodeGen framework.</p>
     *
     * <p>For each item in a datasource's Array, a row (&lt;tr&gt;) will be generated.
     * You can define any number of QHtmlTableColumns which will result in a &lt;td&gt; for each row.
     * Using the QHtmlTableColumn's Accessor property, you can specify how the data for each cell should be
     * fetched from the datasource.</p>
     *
     * @property string $Caption              string to use as the caption of the table
     * @property string $RowCssClass          class to be given to the row tag
     * @property string $AlternateRowCssClass class to be given to each alternate row tag
     * @property string $HeaderRowCssClass    class to be given the header row
     * @property boolean $ShowHeader           true to show the header row
     * @property boolean $ShowFooter           true to show the footer row
     * @property boolean $RenderColumnTags     true to include col tags in the table output
     * @property boolean $HideIfEmpty          true to completely hide the table if there is no data, vs. drawing the table with no rows.
     * @property boolean $ShowEmptyTable if true, the table will be rendered even if there are no records to display.
     * @property string $EmptyTableText the text to display in the table if ShowEmptyTable is true.
     *
     * @property integer $HeaderRowCount
     * @property integer $CurrentHeaderRowIndex
     * @property-write callable $RowParamsCallback    Set to a callback function to fetch custom attributes for row tags.
     * @property-read integer $CurrentRowIndex      The visual index of the row currently being drawn.
     * @package QCubed\Control
     */
    abstract class TableBase extends PaginatedControl
    {
        /** @var ColumnBase[] */
        protected array $objColumnArray = [];

        /** @var string|null CSS class to be applied to for even rows */
        protected ?string $strRowCssClass = null;
        /** @var string|null CSS class to be applied to for odd rows */
        protected ?string $strAlternateRowCssClass = null;
        /** @var string|null CSS class to be applied to the header row */
        protected ?string $strHeaderRowCssClass = null;
        /** @var bool Show the table header or not? */
        protected bool $blnShowHeader = true;
        /** @var bool Show the table footer or not? */
        protected bool $blnShowFooter = false;
        /** @var bool Column tags have to be rendered or not? */
        protected bool $blnRenderColumnTags = false;
        /** @var string|null Table caption, if applicable */
        protected ?string $strCaption = null;
        /** @var bool When set, the table is hidden/not rendered when the data source is empty */
        protected bool $blnHideIfEmpty = false;
        /** @var boolean */
        protected bool $blnShowEmptyTable = false;
        /** @var string */
        protected string $strEmptyTableText = 'No records';

        /** @var integer */
        protected int $intHeaderRowCount = 1;
        /** @var  integer Used during rendering to report which header row is being drawn in a multi-row header. */
        protected int $intCurrentHeaderRowIndex;

        /** @var  integer Used during rendering to report which visible row is being drawn. */
        protected int $intCurrentRowIndex;

        /** @var callable */
        protected $rowParamsCallback;

        /**
         * Constructor for initializing the control with the given parent object and optional control ID.
         *
         * @param FormBase|ControlBase $objParentObject The parent object for this control.
         * @param string|null $strControlId An optional ID for the control. Defaults to null.
         *
         * @throws Caller
         */
        public function __construct(FormBase|ControlBase $objParentObject, ?string $strControlId = null)
        {
            try {
                parent::__construct($objParentObject, $strControlId);
            } catch (Caller  $objExc) {
                $objExc->incrementOffset();
                throw $objExc;
            }
        }

        /**
         * Parses the post-data for all columns in the `objColumnArray`.
         *
         * @return void
         */
        public function parsePostData(): void
        {
            if ($this->objColumnArray) {
                foreach ($this->objColumnArray as $objColumn) {
                    $objColumn->parsePostData();
                }
            }
        }

        /**
         * Create an indexed column with a specified name and index and add it to the column array
         *
         * @param string|null $strName The name of the column
         * @param mixed|null $mixIndex The index of the column, defaults to the next available index
         * @param integer $intColumnIndex The insertion index of the column, defaults to -1 (append to the end)
         *
         * @return IndexedColumn The created indexed column
         * @throws Caller
         * @throws InvalidCast
         */
        public function createIndexedColumn(?string $strName = '', mixed $mixIndex = null, int $intColumnIndex = -1): IndexedColumn
        {
            if (is_null($mixIndex)) {
                $mixIndex = count($this->objColumnArray);
            }
            $objColumn = new IndexedColumn($strName, $mixIndex);
            $this->addColumnAt($intColumnIndex, $objColumn);
            return $objColumn;
        }

        /**
         * Creates a new property column and adds it to the list of columns at the specified index.
         *
         * @param string $strName The name of the column.
         * @param string $strProperty The property associated with the column.
         * @param integer $intColumnIndex The index at which to insert the column. Defaults to -1, which appends it to the end.
         * @param mixed|null $objBaseNode Optional base node for the column.
         *
         * @return PropertyColumn The created property column.
         * @throws Caller
         * @throws InvalidCast
         */
        public function createPropertyColumn(string $strName, string $strProperty, int $intColumnIndex = -1, mixed $objBaseNode = null): PropertyColumn
        {
            $objColumn = new PropertyColumn($strName, $strProperty, $objBaseNode);
            $this->addColumnAt($intColumnIndex, $objColumn);
            return $objColumn;
        }

        /**
         * Create a new node column with the specified name and nodes and optionally insert it at a specified index.
         *
         * @param string $strName The name of the column.
         * @param mixed $objNodes The nodes to associate with the column.
         * @param int $intColumnIndex The index at which the column should be added. Defaults to -1, which appends the column at the end.
         *
         * @return NodeColumn The created NodeColumn instance.
         * @throws Caller
         * @throws InvalidCast
         */
        public function createNodeColumn(string $strName, mixed $objNodes, int $intColumnIndex = -1): NodeColumn
        {
            try {
                $objColumn = new NodeColumn($strName, $objNodes);
                $this->addColumnAt($intColumnIndex, $objColumn);
                return $objColumn;
            } catch (Caller $e) {
                $e->incrementOffset();
                throw $e;
            }
        }

        /**
         * Create a callable column and add it to the specified index in the column array
         *
         * @param string $strName Name of the column
         * @param callable $objCallable A callable that defines the functionality of the column
         * @param integer $intColumnIndex Index at which the column should be added, defaults to -1 (end of the list)
         * @param mixed|null $mixParams Optional parameters to pass to the callable
         *
         * @return CallableColumn
         * @throws Caller
         * @throws InvalidCast
         */
        public function createCallableColumn(string $strName, callable $objCallable, int $intColumnIndex = -1, mixed $mixParams = null): CallableColumn
        {
            try {
                $objColumn = new CallableColumn($strName, $objCallable, $mixParams);
                $this->addColumnAt($intColumnIndex, $objColumn);
                return $objColumn;
            } catch (Caller $e) {
                $e->incrementOffset();
                throw $e;
            }

        }

        /**
         * Create a virtual attribute column and add it to the table at the specified index.
         *
         * @param string $strName The name of the column.
         * @param string $strAttribute The attribute used for the virtual column.
         * @param integer $intColumnIndex The index at which to insert the column. Defaults to -1 for appending at the end.
         *
         * @return VirtualAttributeColumn The created virtual attribute column.
         * @throws Caller
         * @throws InvalidCast
         */
        public function createVirtualAttributeColumn(string $strName, string $strAttribute, int $intColumnIndex = -1): VirtualAttributeColumn
        {
            $objColumn = new VirtualAttributeColumn($strName, $strAttribute);
            $this->addColumnAt($intColumnIndex, $objColumn);
            return $objColumn;
        }

        /**
         * Add a link column.
         *
         * @param string $strName Column name to be displayed in the table header.
         * @param string $mixText The text to display as the label of the anchor, a callable callback to get the text,
         *   a string that represents a property chain or a multidimensional array, or an array that represents the same. Depends on
         *   what time of the row item is passed.
         * @param array|string|Proxy|null $mixDestination The text representing the destination of the anchor, a callable callback to get the destination,
         *   a string that represents a property chain or a multidimensional array, or an array that represents the same,
         *   or a Proxy. Depends on what type of row item is passed.
         * @param array|string|null $getVars An array of key=>value pairs to use as the GET variables in the link URL,
         *   or in the case of a Proxy, possibly a string to represent the action parameter. In either case, each item
         *   can be a property chain, an array index list, or a callable callback as specified above.  If the destination is a
         *   Proxy, this would be what to use as the action parameter.
         * @param array|null $tagAttributes An array of key=>value pairs to use as additional attributes in the tag.
         *   For example, it could be used to add a class or an id to each tag.
         * @param bool $blnAsButton Only used if this is drawing a Proxy. Will draw the proxy as a button.
         * @param int $intColumnIndex
         * @return LinkColumn
         * @throws Caller
         * @throws InvalidCast
         */
        public function createLinkColumn(
            string                  $strName,
            string                  $mixText,
            array|string|Proxy|null $mixDestination = null,
            mixed                   $getVars = null,
            ?array                  $tagAttributes = null,
            ?bool                   $blnAsButton = false,
            int                     $intColumnIndex = -1
        ): LinkColumn
        {
            $objColumn = new LinkColumn($strName,
                $mixText,
                $mixDestination,
                $getVars,
                $tagAttributes,
                $blnAsButton);
            $this->addColumnAt($intColumnIndex, $objColumn);
            return $objColumn;
        }

        /**
         * Move a column to a specified index and optionally rename it.
         *
         * @param string $strName The name of the column to be moved.
         * @param integer $intColumnIndex The index to move the column to. Defaults to -1, which appends the column.
         * @param string|null $strNewName Optional new name for the column.
         *
         * @return ColumnBase|null The moved column.
         * @throws Caller
         * @throws InvalidCast
         */
        public function moveColumn(string $strName, int $intColumnIndex = -1, ?string $strNewName = null): ?ColumnBase
        {
            $col = $this->removeColumnByName($strName);
            $this->addColumnAt($intColumnIndex, $col);
            if ($strNewName !== null) {
                $col->Name = $strNewName;
            }
            return $col;
        }

        /**
         * Rename a column by changing its name from the old name to the new name
         *
         * @param string $strOldName The current name of the column to be renamed
         * @param string $strNewName The new name to assign to the column
         *
         * @return ColumnBase|null The updated column object with the new name
         */
        public function renameColumn(string $strOldName, string $strNewName): ?ColumnBase
        {
            $col = $this->getColumnByName($strOldName);
            $col->Name = $strNewName;
            return $col;
        }

        /**
         * Add a column to the collection of columns.
         *
         * @param ColumnBase $objColumn The column to be added.
         *
         * @return ColumnBase The column that was added.
         * @throws Caller
         * @throws InvalidCast
         */
        public function addColumn(ColumnBase $objColumn): ColumnBase
        {
            $this->addColumnAt(-1, $objColumn);
            return $objColumn;
        }

        /**
         * Add a column at the specified index in the column array. If the index is out of range, the column is added at the end.
         *
         * @param integer $intColumnIndex The index where the column should be added
         * @param ColumnBase $objColumn The column object to be added
         *
         * @return void
         * @throws Caller
         * @throws InvalidCast
         */
        public function addColumnAt(int $intColumnIndex, ColumnBase $objColumn): void
        {
            try {
                $intColumnIndex = Type::cast($intColumnIndex, Type::INTEGER);
            } catch (InvalidCast $objExc) {
                $objExc->incrementOffset();
                throw $objExc;
            }
            $this->blnModified = true;
            $objColumn->_ParentTable = $this;
            if ($intColumnIndex < 0 || $intColumnIndex > count($this->objColumnArray)) {
                $this->objColumnArray[] = $objColumn;
            } elseif ($intColumnIndex == 0) {
                $this->objColumnArray = array_merge(array($objColumn), $this->objColumnArray);
            } else {
                $this->objColumnArray = array_merge(array_slice($this->objColumnArray, 0, $intColumnIndex),
                    array($objColumn),
                    array_slice($this->objColumnArray, $intColumnIndex));
            }
        }

        /**
         * Remove the column at the specified index and return it.
         *
         * @param integer $intColumnIndex The index of the column to be removed.
         *
         * @return ColumnBase The removed column.
         *
         * @throws Caller
         * @throws IndexOutOfRange Thrown when the provided index is outside the valid range of columns.
         * @throws InvalidCast Thrown when the given index cannot be cast to an integer.
         */
        public function removeColumn(int $intColumnIndex): ColumnBase
        {
            $this->blnModified = true;
            try {
                $intColumnIndex = Type::cast($intColumnIndex, Type::INTEGER);
            } catch (InvalidCast $objExc) {
                $objExc->incrementOffset();
                throw $objExc;
            }
            if ($intColumnIndex < 0 || $intColumnIndex > count($this->objColumnArray)) {
                throw new IndexOutOfRange($intColumnIndex, "RemoveColumn()");
            }

            $col = $this->objColumnArray[$intColumnIndex];
            array_splice($this->objColumnArray, $intColumnIndex, 1);
            return $col;
        }

        /**
         * Remove the column with the specified ID.
         *
         * @param string $strId The ID of the column to be removed.
         *
         * @return void
         * @throws Caller
         * @throws IndexOutOfRange
         * @throws InvalidCast
         */
        public function removeColumnById(string $strId): void
        {
            if ($this->objColumnArray && ($count = count($this->objColumnArray))) {
                for ($i = 0; $i < $count; $i++) {
                    if ($this->objColumnArray[$i]->Id == $strId) {
                        $this->removeColumn($i);
                        return;
                    }
                }
            }
        }

        /**
         * Remove a column by its name and return the removed column, or null if not found.
         *
         * @param string $strName The name of the column to remove.
         *
         * @return ColumnBase|null The removed column if found, or null otherwise.
         */
        public function removeColumnByName(string $strName): ?ColumnBase
        {
            $this->blnModified = true;
            for ($intIndex = 0; $intIndex < count($this->objColumnArray); $intIndex++) {
                if ($this->objColumnArray[$intIndex]->Name == $strName) {
                    $col = $this->objColumnArray[$intIndex];
                    array_splice($this->objColumnArray, $intIndex, 1);
                    return $col;
                }
            }
            return null;
        }

        /**
         * Remove columns by their names.
         *
         * @param string $strName The name of the column to remove. Multiple column names can be passed as separate arguments.
         *
         * @return array The result of the `removeColumns` method, which depends on its implementation.
         */
        public function removeColumnsByName(string $strName/*...*/): array
        {
            return $this->removeColumns(func_get_args());
        }

        /**
         * Remove columns with names matching those in the provided array of names.
         *
         * @param string[] $strNamesArray An array of column names to be removed.
         *
         * @return ColumnBase[] An array of removed columns.
         */
        public function removeColumns(array $strNamesArray): array
        {
            $this->blnModified = true;
            $kept = array();
            $removed = array();
            foreach ($this->objColumnArray as $objColumn) {
                if (!in_array($objColumn->Name, $strNamesArray)) {
                    $kept[] = $objColumn;
                } else {
                    $removed[] = $objColumn;
                }
            }
            $this->objColumnArray = $kept;
            return $removed;
        }

        /**
         * Remove all columns and mark the object as modified
         *
         * @return void
         */
        public function removeAllColumns(): void
        {
            $this->blnModified = true;
            $this->objColumnArray = array();
        }

        /**
         * Hides all columns by setting their visibility to false.
         *
         * @return void
         */
        public function hideAllColumns(): void
        {
            foreach ($this->objColumnArray as $objColumn) {
                $objColumn->Visible = false;
            }
            $this->blnModified = true;
        }

        /**
         * Set all columns to visible and mark the object as modified.
         *
         * @return void
         */
        public function showAllColumns(): void
        {
            foreach ($this->objColumnArray as $objColumn) {
                $objColumn->Visible = true;
            }
            $this->blnModified = true;
        }

        /**
         * Retrieve all columns from the column array.
         *
         * @return ColumnBase[] An array of all column objects.
         */
        public function getAllColumns(): array
        {
            return $this->objColumnArray;
        }

        /**
         * Retrieves a column based on its index, with an option to filter by visibility.
         *
         * @param int $intColumnIndex The index of the column to retrieve.
         * @param bool $blnVisible If true, only visible columns are considered; otherwise, all columns are included.
         * @return ColumnBase|null The column at the specified index if found, or null if not found.
         */
        public function getColumn(int $intColumnIndex, bool $blnVisible = false): ?ColumnBase
        {
            if (!$blnVisible) {
                if (array_key_exists($intColumnIndex, $this->objColumnArray)) {
                    return $this->objColumnArray[$intColumnIndex];
                }
            } else {
                $i = 0;
                foreach ($this->objColumnArray as $objColumn) {
                    if ($objColumn->Visible) {
                        if ($i == $intColumnIndex) {
                            return $objColumn;
                        }
                        $i++;
                    }
                }
            }
            return null;
        }

        /**
         * Retrieves a column by its name.
         *
         * @param string $strName The name of the column to retrieve.
         * @return ColumnBase|null The column matching the specified name if found, or null if not found.
         */
        public function getColumnByName(string $strName): ?ColumnBase
        {
            if ($this->objColumnArray) {
                foreach ($this->objColumnArray as $objColumn) {
                    if ($objColumn->Name == $strName) {
                        return $objColumn;
                    }
                }
            }
            return null;
        }

        /**
         * Retrieves a column using its unique identifier.
         *
         * @param string $strId The unique identifier of the column to retrieve.
         * @return ColumnBase|null The column with the specified identifier if found, or null if not found.
         */
        public function getColumnById(string $strId): ?ColumnBase
        {
            if ($this->objColumnArray) {
                foreach ($this->objColumnArray as $objColumn) {
                    if ($objColumn->Id == $strId) {
                        return $objColumn;
                    }
                }
            }
            return null;
        }

        /**
         * Retrieves the index of a column based on its name.
         *
         * @param string $strName The name of the column to search for.
         * @return int The index of the column if found, or -1 if not found.
         */
        public function getColumnIndex(string $strName): int
        {
            $intIndex = -1;
            if ($this->objColumnArray) {
                foreach ($this->objColumnArray as $objColumn) {
                    ++$intIndex;
                    if ($objColumn->Name == $strName) {
                        return $intIndex;
                    }
                }
            }
            return $intIndex;
        }

        /**
         * Retrieves an array of columns that match the given name.
         *
         * @param string $strName The name of the columns to retrieve.
         * @return array An array of columns that have the specified name.
         */
        public function getColumnsByName(string $strName): array
        {
            $objColumnArrayToReturn = array();
            if ($this->objColumnArray) {
                foreach ($this->objColumnArray as $objColumn) {
                    if ($objColumn->Name == $strName) {
                        $objColumnArrayToReturn[] = $objColumn;
                    }
                }
            }
            return $objColumnArrayToReturn;
        }

        /**
         * Generates the HTML for the header rows of a table.
         *
         * Iterates over the defined number of header rows and constructs the corresponding HTML
         * by rendering the header cells for each column.
         *
         * @return string The HTML string representing the header rows of the table.
         */
        protected function getHeaderRowHtml(): string
        {
            $strToReturn = '';
            for ($i = 0; $i < $this->intHeaderRowCount; $i++) {
                $this->intCurrentHeaderRowIndex = $i;

                $strCells = '';
                if ($this->objColumnArray) {
                    foreach ($this->objColumnArray as $objColumn) {
                        $strCells .= $objColumn->renderHeaderCell();
                    }
                }
                $strToReturn .= Html::renderTag('tr', $this->getHeaderRowParams(), $strCells);
            }
            return $strToReturn;
        }

        /**
         * Retrieves the parameters for the header row, including any applicable CSS class.
         *
         * @return array An associative array of parameters for the header row, including the 'class' key if a CSS class is specified.
         */
        protected function getHeaderRowParams(): array
        {
            $strParamArray = array();
            if ($strClass = $this->strHeaderRowCssClass) {
                $strParamArray['class'] = $strClass;
            }
            return $strParamArray;
        }

        /**
         * Generates the HTML for a single data grid row.
         *
         * @param mixed $objObject The data object corresponding to the current row.
         * @param int $intCurrentRowIndex The index of the current row in the grid.
         * @return string The HTML string representation of the data grid row.
         */
        protected function getDataGridRowHtml(mixed $objObject, int $intCurrentRowIndex): string
        {
            $strCells = '';
            foreach ($this->objColumnArray as $objColumn) $strCells .= $objColumn->renderCell($objObject);

            return Html::renderTag('tr', $this->getRowParams($objObject, $intCurrentRowIndex), $strCells);
        }

        /**
         * Retrieves an array of parameters for a specific row, based on the object and its index.
         *
         * @param mixed $objObject The object associated with the current row.
         * @param int $intCurrentRowIndex The index of the current row.
         * @return array An associative array of row parameters, which may include class, id, style, and other attributes.
         */
        protected function getRowParams(mixed $objObject, int $intCurrentRowIndex): array
        {
            $strParamArray = array();
            if ($this->rowParamsCallback) {
                $strParamArray = call_user_func($this->rowParamsCallback, $objObject, $intCurrentRowIndex);
            }
            if ($strClass = $this->getRowClass($objObject, $intCurrentRowIndex)) {
                $strParamArray['class'] = $strClass;
            }

            if ($strId = $this->getRowId($objObject, $intCurrentRowIndex)) {
                $strParamArray['id'] = $strId;
            }

            if ($strStyle = $this->getRowStyle($objObject, $intCurrentRowIndex)) {
                $strParamArray['style'] = $strStyle;
            }
            return $strParamArray;
        }

        /**
         * Retrieves the row ID based on the provided object and row index.
         *
         * @param mixed $objObject The object associated with the row.
         * @param int $intRowIndex The index of the row to retrieve the ID for.
         * @return null Always returns null.
         */
        protected function getRowId(mixed $objObject, int $intRowIndex): null
        {
            return null;
        }

        /**
         * Retrieves the style for a specific row based on the given object and row index.
         *
         * @param mixed $objObject The object associated with the row.
         * @param int $intRowIndex The index of the row to retrieve the style for.
         * @return null The style for the row, or null if not applicable.
         */
        protected function getRowStyle(mixed $objObject, int $intRowIndex): null
        {
            return null;
        }

        /**
         * Determines the CSS class to be applied to a row based on its index and object data.
         *
         * @param mixed $objObject The object associated with the row.
         * @param int $intRowIndex The index of the row.
         * @return string|null The CSS class for the row if defined, or null if no class is applicable.
         */
        protected function getRowClass(mixed $objObject, int $intRowIndex): ?string
        {
            if (($intRowIndex % 2) == 1 && $this->strAlternateRowCssClass) {
                return $this->strAlternateRowCssClass;
            } else {
                if ($this->strRowCssClass) {
                    return $this->strRowCssClass;
                } else {
                    return null;
                }
            }
        }

        /**
         * Generates the HTML for the footer row.
         *
         * @return string|null The HTML for the footer row, or null if not applicable.
         */
        protected function getFooterRowHtml(): ?string
        {
            return '';
        }

        /**
         * Generates the HTML for column tags, including only visible columns.
         *
         * @return string The generated HTML for all visible column tags.
         */
        protected function getColumnTagsHtml(): string
        {
            $strToReturn = '';
            $len = count($this->objColumnArray);
            $i = 0;
            while ($i < $len) {
                $objColumn = $this->objColumnArray[$i];
                if ($objColumn->Visible) {
                    $strToReturn .= $objColumn->renderColTag() . _nl();
                }
                $i += $objColumn->Span;
            }
            return $strToReturn;
        }

        /**
         * Renders the caption HTML for the element if a caption is set.
         *
         * @return string The rendered caption HTML or an empty string if no caption is set.
         */
        protected function renderCaption(): string
        {
            $strHtml = '';
            if ($this->strCaption) {
                $strHtml .= '<caption>' . QString::htmlEntities($this->strCaption) . '</caption>' . _nl();
            }
            return $strHtml;
        }

        /**
         * Generates and returns the HTML for the control, including the table structure, headers, footers, and data rows.
         *
         * The method binds the data source, processes column tags, header, and footer rows if enabled,
         * and iterates over the data source to render rows in the table body. If the data source is empty
         * and hiding the control when empty is enabled, it returns an empty string.
         *
         * @return string The complete HTML string for the control, or an empty string if the data source is empty and hiding is enabled.
         * @throws Caller
         */
        protected function getControlHtml(): string
        {
            $this->dataBind();

            if (empty($this->objDataSource) && $this->blnHideIfEmpty) {
                $this->objDataSource = [];
                return '';
            }

            $strHtml = $this->renderCaption();

            // Column tags (if applicable)
            if ($this->blnRenderColumnTags) {
                $strHtml .= $this->getColumnTagsHtml();
            }

            // Header Row (if applicable)
            if ($this->blnShowHeader) {
                $strHtml .= Html::renderTag('thead', null, $this->getHeaderRowHtml());
            }

            // Footer Row (if applicable)
            if ($this->blnShowFooter) {
                $strHtml .= Html::renderTag('tfoot', null, $this->getFooterRowHtml());
            }

            // DataGrid Rows
            $strRows = '';
            $this->intCurrentRowIndex = 0;

            /**
             * Handle empty datasource rendering
             */
            if (empty($this->objDataSource)) {

                // Hide the table if HideIfEmpty is enabled
                if ($this->blnHideIfEmpty) {
                    $this->objDataSource = [];
                    return '';
                }

                // Show empty row if enabled
                if ($this->blnShowEmptyTable) {

                    // Calculate column count (visible columns only)
                    $intColumnCount = 0;
                    foreach ($this->objColumnArray as $objColumn) {
                        if ($objColumn->Visible) {
                            $intColumnCount += $objColumn->Span;
                        }
                    }
                    if ($intColumnCount < 1) {
                        $intColumnCount = 1; // safety
                    }

                    // Render <td colspan="X"> message </td>
                    $strEmptyTd = Html::renderTag(
                        'td',
                        [
                            'colspan' => $intColumnCount,
                            'class'   => 'table-empty-message'
                        ],
                        Html::renderString($this->strEmptyTableText)
                    );

                    // Wrap in <tr>
                    $strRows .= Html::renderTag('tr', null, $strEmptyTd);
                }

            } else {

                // Render actual records
                foreach ($this->objDataSource as $objObject) {
                    $strRows .= $this->getDataGridRowHtml($objObject, $this->intCurrentRowIndex);
                    $this->intCurrentRowIndex++;
                }
            }

            // Render <tbody>
            $strHtml .= Html::renderTag('tbody', null, $strRows);

            $strHtml = $this->renderTag('table', null, null, $strHtml);

            $this->objDataSource = [];

            return $strHtml;
        }

        /**
         * Prepares the object for serialization by putting its properties into a restorable state.
         *
         * @return array Returns an array of properties that should be serialized.
         */
        public function sleep(): array
        {
            if ($this->objColumnArray) {
                foreach ($this->objColumnArray as $objColumn) {
                    $objColumn->sleep();
                }
            }
            $this->rowParamsCallback = Q\Project\Control\ControlBase::sleepHelper($this->rowParamsCallback);

            return parent::sleep();
        }

        /**
         * Restores the state of the object during the wakeup process and adjusts associated components accordingly.
         *
         * @param FormBase $objForm The form instance used during the wakeup process.
         * @return void
         */
        public function wakeup(FormBase $objForm): void
        {
            parent::wakeup($objForm);
            $this->rowParamsCallback = Q\Project\Control\ControlBase::wakeupHelper($objForm, $this->rowParamsCallback);
            if ($this->objColumnArray) {
                foreach ($this->objColumnArray as $objColumn) {
                    $objColumn->wakeup($objForm);
                }
            }
        }

        /**
         * Magic method to get the value of a property by name.
         *
         * @param string $strName The name of the property to retrieve.
         *
         * @return mixed The value of the specified property, or the value from the parent class's __get if the
         *     property is not found.
         * @throws Caller If the property does not exist and cannot be retrieved by the parent class.
         * @throws \Exception
         */
        public function __get(string $strName): mixed
        {
            switch ($strName) {
                case 'RowCssClass':
                    return $this->strRowCssClass;
                case 'AlternateRowCssClass':
                    return $this->strAlternateRowCssClass;
                case 'HeaderRowCssClass':
                    return $this->strHeaderRowCssClass;
                case 'ShowHeader':
                    return $this->blnShowHeader;
                case 'ShowFooter':
                    return $this->blnShowFooter;
                case 'RenderColumnTags':
                    return $this->blnRenderColumnTags;
                case 'Caption':
                    return $this->strCaption;
                case 'HeaderRowCount':
                    return $this->intHeaderRowCount;
                case 'CurrentHeaderRowIndex':
                    return $this->intCurrentHeaderRowIndex;
                case 'HideIfEmpty':
                    return $this->blnHideIfEmpty;
                case "ShowEmptyTable":
                    return $this->blnShowEmptyTable;
                case "EmptyTableText":
                    return $this->strEmptyTableText;
                case 'CurrentRowIndex':
                    return $this->intCurrentRowIndex;

                default:
                    try {
                        return parent::__get($strName);
                    } catch (Caller $objExc) {
                        $objExc->incrementOffset();
                        throw $objExc;
                    }
            }
        }

        /**
         * Sets the value of a given property based on its name.
         *
         * @param string $strName The name of the property to set.
         * @param mixed $mixValue The value to assign to the property. The value's type will be validated and cast as needed.
         * @return void
         * @throws Caller
         * @throws InvalidCast
         * @throws Throwable
         */
        public function __set(string $strName, mixed $mixValue): void
        {
            switch ($strName) {
                case "RowCssClass":
                    try {
                        $this->strRowCssClass = Type::cast($mixValue, Type::STRING);
                        break;
                    } catch (InvalidCast $objExc) {
                        $objExc->incrementOffset();
                        throw $objExc;
                    }

                case "AlternateRowCssClass":
                    try {
                        $this->strAlternateRowCssClass = Type::cast($mixValue, Type::STRING);
                        break;
                    } catch (InvalidCast $objExc) {
                        $objExc->incrementOffset();
                        throw $objExc;
                    }

                case "HeaderRowCssClass":
                    try {
                        $this->strHeaderRowCssClass = Type::cast($mixValue, Type::STRING);
                        break;
                    } catch (InvalidCast $objExc) {
                        $objExc->incrementOffset();
                        throw $objExc;
                    }

                case "ShowHeader":
                    try {
                        $this->blnShowHeader = Type::cast($mixValue, Type::BOOLEAN);
                        break;
                    } catch (InvalidCast $objExc) {
                        $objExc->incrementOffset();
                        throw $objExc;
                    }

                case "ShowFooter":
                    try {
                        $this->blnShowFooter = Type::cast($mixValue, Type::BOOLEAN);
                        break;
                    } catch (InvalidCast $objExc) {
                        $objExc->incrementOffset();
                        throw $objExc;
                    }

                case "RenderColumnTags":
                    try {
                        $this->blnRenderColumnTags = Type::cast($mixValue, Type::BOOLEAN);
                        break;
                    } catch (InvalidCast $objExc) {
                        $objExc->incrementOffset();
                        throw $objExc;
                    }

                case "Caption":
                    try {
                        $this->strCaption = Type::cast($mixValue, Type::STRING);
                        break;
                    } catch (InvalidCast $objExc) {
                        $objExc->incrementOffset();
                        throw $objExc;
                    }

                case "HeaderRowCount":
                    try {
                        $this->intHeaderRowCount = Type::cast($mixValue, Type::INTEGER);
                        break;
                    } catch (InvalidCast $objExc) {
                        $objExc->incrementOffset();
                        throw $objExc;
                    }

                case "HideIfEmpty":
                    try {
                        $this->blnHideIfEmpty = Type::cast($mixValue, Type::BOOLEAN);
                        break;
                    } catch (InvalidCast $objExc) {
                        $objExc->incrementOffset();
                        throw $objExc;
                    }

                case "ShowEmptyTable":
                    try {
                        $this->blnShowEmptyTable = Type::cast($mixValue, Type::BOOLEAN);
                        break;
                    } catch (InvalidCast $objExc) {
                        $objExc->incrementOffset();
                        throw $objExc;
                    }

                case "EmptyTableText":
                    try {
                        $this->strEmptyTableText = Type::cast($mixValue, Type::STRING);
                        break;
                    } catch (InvalidCast $objExc) {
                        $objExc->incrementOffset();
                        throw $objExc;
                    }

                case "RowParamsCallback":
                    try {
                        $this->rowParamsCallback = Type::cast($mixValue, Type::CALLABLE_TYPE);
                        break;
                    } catch (InvalidCast $objExc) {
                        $objExc->incrementOffset();
                        throw $objExc;
                    }


                default:
                    try {
                        parent::__set($strName, $mixValue);
                        break;
                    } catch (Caller $objExc) {
                        $objExc->incrementOffset();
                        throw $objExc;
                    }
            }
        }

        /**
         * Retrieves the parameters used for configuring the model connector.
         *
         * @return array An array of parameters, including inherited and specific options such as CSS classes for rows,
         * header and footer visibility, rendering column tags, table caption, and behavior when data is empty.
         * @throws Caller
         */
        public static function getModelConnectorParams(): array
        {
            return array_merge(parent::getModelConnectorParams(), array(
                new Q\ModelConnector\Param(get_called_class(), 'RowCssClass', 'CSS class given to each row',
                    Type::STRING),
                new Q\ModelConnector\Param(get_called_class(), 'AlternateRowCssClass', 'CSS class given to every other row',
                    Type::STRING),
                new Q\ModelConnector\Param(get_called_class(), 'HeaderRowCssClass', 'CSS class given to the header rows',
                    Type::STRING),
                new Q\ModelConnector\Param(get_called_class(), 'ShowHeader',
                    'Whether or not to show the header. Default is true.', Type::BOOLEAN),
                new Q\ModelConnector\Param(get_called_class(), 'ShowFooter',
                    'Whether or not to show the footer. Default is false.', Type::BOOLEAN),
                new Q\ModelConnector\Param(get_called_class(), 'RenderColumnTags',
                    'Whether or not to render HTML column tags for the columns. Column tags are only needed in special situations. Default is false.',
                    Type::BOOLEAN),
                new Q\ModelConnector\Param(get_called_class(), 'Caption', 'Text to print in the caption tag of the table.',
                    Type::STRING),
                new Q\ModelConnector\Param(get_called_class(), 'HideIfEmpty',
                    'Whether to draw nothing if there is no data, or draw the table tags with no cells instead. The default is to drag the table tags.',
                    Type::BOOLEAN)
            ));
        }
    }
