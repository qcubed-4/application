<?php
/**
 *
 * Part of the QCubed PHP framework.
 *
 * @license MIT
 *
 */

namespace QCubed\Control;

use QCubed as Q;
use QCubed\Exception\Caller;
use QCubed\Exception\IndexOutOfRange;
use QCubed\Exception\InvalidCast;
use QCubed\Html;
use QCubed\Table\CallableColumn;
use QCubed\Table\ColumnBase;
use QCubed\QString;
use QCubed\Table\IndexedColumn;
use QCubed\Table\LinkColumn;
use QCubed\Table\NodeColumn;
use QCubed\Table\PropertyColumn;
use QCubed\Table\VirtualAttributeColumn;
use QCubed\Type;
use Throwable;


/**
 * Class Table
 *
 * <p>This control is used to display a simple HTML table.
 *
 * <p>The control itself will display things based off of an array of objects that gets set as the "Data Source".
 * It is particularly useful when combined with the Class::loadArrayByXXX() functions or the Class::loadAll()
 * that is generated by the CodeGen framework, or when combined with custom Class ArrayLoaders that you define
 *  yourself, but whose structure is based off of the CodeGen framework.</p>
 *
 * <p>For each item in a datasource's Array, a row (&lt;tr&gt;) will be generated.
 * You can define any number of QHtmlTableColumns which will result in a &lt;td&gt; for each row.
 * Using the QHtmlTableColumn's Accessor property, you can specify how the data for each cell should be
 * fetched from the datasource.</p>
 *
 * @property string $Caption              string to use as the caption of the table
 * @property string $RowCssClass          class to be given to the row tag
 * @property string $AlternateRowCssClass class to be given to each alternate row tag
 * @property string $HeaderRowCssClass    class to be given the header row
 * @property boolean $ShowHeader           true to show the header row
 * @property boolean $ShowFooter           true to show the footer row
 * @property boolean $RenderColumnTags     true to include col tags in the table output
 * @property boolean $HideIfEmpty          true to completely hide the table if there is no data, vs. drawing the table with no rows.
 * @property integer $HeaderRowCount
 * @property integer $CurrentHeaderRowIndex
 * @property-write callable $RowParamsCallback    Set to a callback function to fetch custom attributes for row tags.
 * @property-read integer $CurrentRowIndex      The visual index of the row currently being drawn.
 * @package QCubed\Control
 */
abstract class TableBase extends PaginatedControl
{
    /** @var ColumnBase[] */
    protected array $objColumnArray = [];

    /** @var string|null CSS class to be applied to for even rows */
    protected ?string $strRowCssClass = null;
    /** @var string|null CSS class to be applied to for odd rows */
    protected ?string $strAlternateRowCssClass = null;
    /** @var string|null CSS class to be applied to the header row */
    protected ?string $strHeaderRowCssClass = null;
    /** @var bool Show the table header or not? */
    protected bool $blnShowHeader = true;
    /** @var bool Show the table footer or not? */
    protected bool $blnShowFooter = false;
    /** @var bool Column tags have to be rendered or not? */
    protected bool $blnRenderColumnTags = false;
    /** @var string|null Table caption, if applicable */
    protected ?string $strCaption = null;
    /** @var bool When set, the table is hidden/not rendered when the data source is empty */
    protected bool $blnHideIfEmpty = false;

    /** @var integer */
    protected int $intHeaderRowCount = 1;
    /** @var  integer Used during rendering to report which header row is being drawn in a multi-row header. */
    protected int $intCurrentHeaderRowIndex;

    /** @var  integer Used during rendering to report which visible row is being drawn. */
    protected int $intCurrentRowIndex;

    /** @var callable */
    protected $rowParamsCallback;

    /**
     * Constructor for initializing the control with the given parent object and optional control ID.
     *
     * @param FormBase|ControlBase $objParentObject The parent object for this control.
     * @param string|null $strControlId An optional ID for the control. Defaults to null.
     *
     * @throws Caller
     */
    public function __construct(FormBase|ControlBase $objParentObject, ?string $strControlId = null)
    {
        try {
            parent::__construct($objParentObject, $strControlId);
        } catch (Caller  $objExc) {
            $objExc->incrementOffset();
            throw $objExc;
        }
    }

    /**
     * Parses the post-data for all columns in the `objColumnArray`.
     *
     * @return void
     */
    public function parsePostData(): void
    {
        if ($this->objColumnArray) {
            foreach ($this->objColumnArray as $objColumn) {
                $objColumn->parsePostData();
            }
        }
    }

    /**
     * Create an indexed column with a specified name and index and add it to the column array
     *
     * @param string|null $strName The name of the column
     * @param mixed|null $mixIndex The index of the column, defaults to the next available index
     * @param integer $intColumnIndex The insertion index of the column, defaults to -1 (append to the end)
     *
     * @return IndexedColumn The created indexed column
     * @throws Caller
     * @throws InvalidCast
     */
    public function createIndexedColumn(?string $strName = '', mixed $mixIndex = null, int $intColumnIndex = -1): IndexedColumn
    {
        if (is_null($mixIndex)) {
            $mixIndex = count($this->objColumnArray);
        }
        $objColumn = new IndexedColumn($strName, $mixIndex);
        $this->addColumnAt($intColumnIndex, $objColumn);
        return $objColumn;
    }

    /**
     * Creates a new property column and adds it to the list of columns at the specified index.
     *
     * @param string $strName The name of the column.
     * @param string $strProperty The property associated with the column.
     * @param integer $intColumnIndex The index at which to insert the column. Defaults to -1, which appends it to the end.
     * @param mixed|null $objBaseNode Optional base node for the column.
     *
     * @return PropertyColumn The created property column.
     * @throws Caller
     * @throws InvalidCast
     */
    public function createPropertyColumn(string $strName, string $strProperty, int $intColumnIndex = -1, mixed $objBaseNode = null): PropertyColumn
    {
        $objColumn = new PropertyColumn($strName, $strProperty, $objBaseNode);
        $this->addColumnAt($intColumnIndex, $objColumn);
        return $objColumn;
    }

    /**
     * Create a new node column with the specified name and nodes and optionally insert it at a specified index.
     *
     * @param string $strName The name of the column.
     * @param mixed $objNodes The nodes to associate with the column.
     * @param int $intColumnIndex The index at which the column should be added. Defaults to -1, which appends the column at the end.
     *
     * @return NodeColumn The created NodeColumn instance.
     * @throws Caller
     * @throws InvalidCast
     */
    public function createNodeColumn(string $strName, mixed $objNodes, int $intColumnIndex = -1): NodeColumn
    {
        try {
            $objColumn = new NodeColumn($strName, $objNodes);
            $this->addColumnAt($intColumnIndex, $objColumn);
            return $objColumn;
        } catch (Caller $e) {
            $e->incrementOffset();
            throw $e;
        }
    }

    /**
     * Create a callable column and add it to the specified index in the column array
     *
     * @param string $strName Name of the column
     * @param callable $objCallable A callable that defines the functionality of the column
     * @param integer $intColumnIndex Index at which the column should be added, defaults to -1 (end of the list)
     * @param mixed|null $mixParams Optional parameters to pass to the callable
     *
     * @return CallableColumn
     * @throws Caller
     * @throws InvalidCast
     */
    public function createCallableColumn(string $strName, callable $objCallable, int $intColumnIndex = -1, mixed $mixParams = null): CallableColumn
    {
        try {
            $objColumn = new CallableColumn($strName, $objCallable, $mixParams);
            $this->addColumnAt($intColumnIndex, $objColumn);
            return $objColumn;
        } catch (Caller $e) {
            $e->incrementOffset();
            throw $e;
        }

    }

    /**
     * Create a virtual attribute column and add it to the table at the specified index.
     *
     * @param string $strName The name of the column.
     * @param string $strAttribute The attribute used for the virtual column.
     * @param integer $intColumnIndex The index at which to insert the column. Defaults to -1 for appending at the end.
     *
     * @return VirtualAttributeColumn The created virtual attribute column.
     * @throws Caller
     * @throws InvalidCast
     */
    public function createVirtualAttributeColumn(string $strName, string $strAttribute, int $intColumnIndex = -1): VirtualAttributeColumn
    {
        $objColumn = new VirtualAttributeColumn($strName, $strAttribute);
        $this->addColumnAt($intColumnIndex, $objColumn);
        return $objColumn;
    }

    /**
     * Add a link column.
     *
     * @param string $strName Column name to be displayed in the table header.
     * @param string $mixText The text to display as the label of the anchor, a callable callback to get the text,
     *   a string that represents a property chain or a multidimensional array, or an array that represents the same. Depends on
     *   what time of the row item is passed.
     * @param array|string|Proxy|null $mixDestination The text representing the destination of the anchor, a callable callback to get the destination,
     *   a string that represents a property chain or a multidimensional array, or an array that represents the same,
     *   or a Proxy. Depends on what type of row item is passed.
     * @param array|string|null $getVars An array of key=>value pairs to use as the GET variables in the link URL,
     *   or in the case of a Proxy, possibly a string to represent the action parameter. In either case, each item
     *   can be a property chain, an array index list, or a callable callback as specified above.  If the destination is a
     *   Proxy, this would be what to use as the action parameter.
     * @param array|null $tagAttributes An array of key=>value pairs to use as additional attributes in the tag.
     *   For example, it could be used to add a class or an id to each tag.
     * @param bool $blnAsButton Only used if this is drawing a Proxy. Will draw the proxy as a button.
     * @param int $intColumnIndex
     * @return LinkColumn
     * @throws Caller
     * @throws InvalidCast
     */
    public function createLinkColumn(
        string                  $strName,
        string                  $mixText,
        array|string|Proxy|null $mixDestination = null,
        mixed                   $getVars = null,
        ?array                  $tagAttributes = null,
        ?bool                   $blnAsButton = false,
        int                     $intColumnIndex = -1
    ): LinkColumn
    {
        $objColumn = new LinkColumn($strName,
            $mixText,
            $mixDestination,
            $getVars,
            $tagAttributes,
            $blnAsButton);
        $this->addColumnAt($intColumnIndex, $objColumn);
        return $objColumn;
    }

    /**
     * Move a column to a specified index and optionally rename it.
     *
     * @param string $strName The name of the column to be moved.
     * @param integer $intColumnIndex The index to move the column to. Defaults to -1, which appends the column.
     * @param string|null $strNewName Optional new name for the column.
     *
     * @return ColumnBase|null The moved column.
     * @throws Caller
     * @throws InvalidCast
     */
    public function moveColumn(string $strName, int $intColumnIndex = -1, ?string $strNewName = null): ?ColumnBase
    {
        $col = $this->removeColumnByName($strName);
        $this->addColumnAt($intColumnIndex, $col);
        if ($strNewName !== null) {
            $col->Name = $strNewName;
        }
        return $col;
    }

    /**
     * Rename a column by changing its name from the old name to the new name
     *
     * @param string $strOldName The current name of the column to be renamed
     * @param string $strNewName The new name to assign to the column
     *
     * @return ColumnBase|null The updated column object with the new name
     */
    public function renameColumn(string $strOldName, string $strNewName): ?ColumnBase
    {
        $col = $this->getColumnByName($strOldName);
        $col->Name = $strNewName;
        return $col;
    }

    /**
     * Add a column to the collection of columns.
     *
     * @param ColumnBase $objColumn The column to be added.
     *
     * @return ColumnBase The column that was added.
     * @throws Caller
     * @throws InvalidCast
     */
    public function addColumn(ColumnBase $objColumn): ColumnBase
    {
        $this->addColumnAt(-1, $objColumn);
        return $objColumn;
    }

    /**
     * Add a column at the specified index in the column array. If the index is out of range, the column is added at the end.
     *
     * @param integer $intColumnIndex The index where the column should be added
     * @param ColumnBase $objColumn The column object to be added
     *
     * @return void
     * @throws Caller
     * @throws InvalidCast
     */
    public function addColumnAt(int $intColumnIndex, ColumnBase $objColumn): void
    {
        try {
            $intColumnIndex = Type::cast($intColumnIndex, Type::INTEGER);
        } catch (InvalidCast $objExc) {
            $objExc->incrementOffset();
            throw $objExc;
        }
        $this->blnModified = true;
        $objColumn->_ParentTable = $this;
        if ($intColumnIndex < 0 || $intColumnIndex > count($this->objColumnArray)) {
            $this->objColumnArray[] = $objColumn;
        } elseif ($intColumnIndex == 0) {
            $this->objColumnArray = array_merge(array($objColumn), $this->objColumnArray);
        } else {
            $this->objColumnArray = array_merge(array_slice($this->objColumnArray, 0, $intColumnIndex),
                array($objColumn),
                array_slice($this->objColumnArray, $intColumnIndex));
        }
    }

    /**
     * Remove the column at the specified index and return it.
     *
     * @param integer $intColumnIndex The index of the column to be removed.
     *
     * @return ColumnBase The removed column.
     *
     * @throws Caller
     * @throws IndexOutOfRange Thrown when the provided index is outside the valid range of columns.
     * @throws InvalidCast Thrown when the given index cannot be cast to an integer.
     */
    public function removeColumn(int $intColumnIndex): ColumnBase
    {
        $this->blnModified = true;
        try {
            $intColumnIndex = Type::cast($intColumnIndex, Type::INTEGER);
        } catch (InvalidCast $objExc) {
            $objExc->incrementOffset();
            throw $objExc;
        }
        if ($intColumnIndex < 0 || $intColumnIndex > count($this->objColumnArray)) {
            throw new IndexOutOfRange($intColumnIndex, "RemoveColumn()");
        }

        $col = $this->objColumnArray[$intColumnIndex];
        array_splice($this->objColumnArray, $intColumnIndex, 1);
        return $col;
    }

    /**
     * Remove the column with the specified ID.
     *
     * @param string $strId The ID of the column to be removed.
     *
     * @return void
     * @throws Caller
     * @throws IndexOutOfRange
     * @throws InvalidCast
     */
    public function removeColumnById(string $strId): void
    {
        if ($this->objColumnArray && ($count = count($this->objColumnArray))) {
            for ($i = 0; $i < $count; $i++) {
                if ($this->objColumnArray[$i]->Id == $strId) {
                    $this->removeColumn($i);
                    return;
                }
            }
        }
    }

    /**
     * Remove a column by its name and return the removed column, or null if not found.
     *
     * @param string $strName The name of the column to remove.
     *
     * @return ColumnBase|null The removed column if found, or null otherwise.
     */
    public function removeColumnByName(string $strName): ?ColumnBase
    {
        $this->blnModified = true;
        for ($intIndex = 0; $intIndex < count($this->objColumnArray); $intIndex++) {
            if ($this->objColumnArray[$intIndex]->Name == $strName) {
                $col = $this->objColumnArray[$intIndex];
                array_splice($this->objColumnArray, $intIndex, 1);
                return $col;
            }
        }
        return null;
    }

    /**
     * Remove columns by their names.
     *
     * @param string $strName The name of the column to remove. Multiple column names can be passed as separate arguments.
     *
     * @return array The result of the `removeColumns` method, which depends on its implementation.
     */
    public function removeColumnsByName(string $strName/*...*/): array
    {
        return $this->removeColumns(func_get_args());
    }

    /**
     * Remove columns with names matching those in the provided array of names.
     *
     * @param string[] $strNamesArray An array of column names to be removed.
     *
     * @return ColumnBase[] An array of removed columns.
     */
    public function removeColumns(array $strNamesArray): array
    {
        $this->blnModified = true;
        $kept = array();
        $removed = array();
        foreach ($this->objColumnArray as $objColumn) {
            if (!in_array($objColumn->Name, $strNamesArray)) {
                $kept[] = $objColumn;
            } else {
                $removed[] = $objColumn;
            }
        }
        $this->objColumnArray = $kept;
        return $removed;
    }

    /**
     * Remove all columns and mark the object as modified
     *
     * @return void
     */
    public function removeAllColumns(): void
    {
        $this->blnModified = true;
        $this->objColumnArray = array();
    }

    /**
     * Hides all columns by setting their visibility to false.
     *
     * @return void
     */
    public function hideAllColumns(): void
    {
        foreach ($this->objColumnArray as $objColumn) {
            $objColumn->Visible = false;
        }
        $this->blnModified = true;
    }

    /**
     * Set all columns to visible and mark the object as modified.
     *
     * @return void
     */
    public function showAllColumns(): void
    {
        foreach ($this->objColumnArray as $objColumn) {
            $objColumn->Visible = true;
        }
        $this->blnModified = true;
    }

    /**
     * Retrieve all columns from the column array.
     *
     * @return ColumnBase[] An array of all column objects.
     */
    public function getAllColumns(): array
    {
        return $this->objColumnArray;
    }

    /**
     * Retrieves a column based on its index, with an option to filter by visibility.
     *
     * @param int $intColumnIndex The index of the column to retrieve.
     * @param bool $blnVisible If true, only visible columns are considered; otherwise, all columns are included.
     * @return ColumnBase|null The column at the specified index if found, or null if not found.
     */
    public function getColumn(int $intColumnIndex, bool $blnVisible = false): ?ColumnBase
    {
        if (!$blnVisible) {
            if (array_key_exists($intColumnIndex, $this->objColumnArray)) {
                return $this->objColumnArray[$intColumnIndex];
            }
        } else {
            $i = 0;
            foreach ($this->objColumnArray as $objColumn) {
                if ($objColumn->Visible) {
                    if ($i == $intColumnIndex) {
                        return $objColumn;
                    }
                    $i++;
                }
            }
        }
        return null;
    }

    /**
     * Retrieves a column by its name.
     *
     * @param string $strName The name of the column to retrieve.
     * @return ColumnBase|null The column matching the specified name if found, or null if not found.
     */
    public function getColumnByName(string $strName): ?ColumnBase
    {
        if ($this->objColumnArray) {
            foreach ($this->objColumnArray as $objColumn) {
                if ($objColumn->Name == $strName) {
                    return $objColumn;
                }
            }
        }
        return null;
    }

    /**
     * Retrieves a column using its unique identifier.
     *
     * @param string $strId The unique identifier of the column to retrieve.
     * @return ColumnBase|null The column with the specified identifier if found, or null if not found.
     */
    public function getColumnById(string $strId): ?ColumnBase
    {
        if ($this->objColumnArray) {
            foreach ($this->objColumnArray as $objColumn) {
                if ($objColumn->Id == $strId) {
                    return $objColumn;
                }
            }
        }
        return null;
    }

    /**
     * Retrieves the index of a column based on its name.
     *
     * @param string $strName The name of the column to search for.
     * @return int The index of the column if found, or -1 if not found.
     */
    public function getColumnIndex(string $strName): int
    {
        $intIndex = -1;
        if ($this->objColumnArray) {
            foreach ($this->objColumnArray as $objColumn) {
                ++$intIndex;
                if ($objColumn->Name == $strName) {
                    return $intIndex;
                }
            }
        }
        return $intIndex;
    }

    /**
     * Retrieves an array of columns that match the given name.
     *
     * @param string $strName The name of the columns to retrieve.
     * @return array An array of columns that have the specified name.
     */
    public function getColumnsByName(string $strName): array
    {
        $objColumnArrayToReturn = array();
        if ($this->objColumnArray) {
            foreach ($this->objColumnArray as $objColumn) {
                if ($objColumn->Name == $strName) {
                    $objColumnArrayToReturn[] = $objColumn;
                }
            }
        }
        return $objColumnArrayToReturn;
    }

    /**
     * Generates the HTML for the header rows of a table.
     *
     * Iterates over the defined number of header rows and constructs the corresponding HTML
     * by rendering the header cells for each column.
     *
     * @return string The HTML string representing the header rows of the table.
     */
    protected function getHeaderRowHtml(): string
    {
        $strToReturn = '';
        for ($i = 0; $i < $this->intHeaderRowCount; $i++) {
            $this->intCurrentHeaderRowIndex = $i;

            $strCells = '';
            if ($this->objColumnArray) {
                foreach ($this->objColumnArray as $objColumn) {
                    $strCells .= $objColumn->renderHeaderCell();
                }
            }
            $strToReturn .= Html::renderTag('tr', $this->getHeaderRowParams(), $strCells);
        }

        return $strToReturn;
    }

    /**
     * Retrieves the parameters for the header row, including any applicable CSS class.
     *
     * @return array An associative array of parameters for the header row, including the 'class' key if a CSS class is specified.
     */
    protected function getHeaderRowParams(): array
    {
        $strParamArray = array();
        if ($strClass = $this->strHeaderRowCssClass) {
            $strParamArray['class'] = $strClass;
        }
        return $strParamArray;
    }

    /**
     * Generates the HTML for a single data grid row.
     *
     * @param mixed $objObject The data object corresponding to the current row.
     * @param int $intCurrentRowIndex The index of the current row in the grid.
     * @return string The HTML string representation of the data grid row.
     */
    protected function getDataGridRowHtml(mixed $objObject, int $intCurrentRowIndex): string
    {
        $strCells = '';
        foreach ($this->objColumnArray as $objColumn) $strCells .= $objColumn->renderCell($objObject);

        return Html::renderTag('tr', $this->getRowParams($objObject, $intCurrentRowIndex), $strCells);
    }

    /**
     * Retrieves an array of parameters for a specific row, based on the object and its index.
     *
     * @param mixed $objObject The object associated with the current row.
     * @param int $intCurrentRowIndex The index of the current row.
     * @return array An associative array of row parameters, which may include class, id, style, and other attributes.
     */
    protected function getRowParams(mixed $objObject, int $intCurrentRowIndex): array
    {
        $strParamArray = array();
        if ($this->rowParamsCallback) {
            $strParamArray = call_user_func($this->rowParamsCallback, $objObject, $intCurrentRowIndex);
        }
        if ($strClass = $this->getRowClass($objObject, $intCurrentRowIndex)) {
            $strParamArray['class'] = $strClass;
        }

        if ($strId = $this->getRowId($objObject, $intCurrentRowIndex)) {
            $strParamArray['id'] = $strId;
        }

        if ($strStyle = $this->getRowStyle($objObject, $intCurrentRowIndex)) {
            $strParamArray['style'] = $strStyle;
        }
        return $strParamArray;
    }

    /**
     * Retrieves the row ID based on the provided object and row index.
     *
     * @param mixed $objObject The object associated with the row.
     * @param int $intRowIndex The index of the row to retrieve the ID for.
     * @return null Always returns null.
     */
    protected function getRowId(mixed $objObject, int $intRowIndex): null
    {
        return null;
    }

    /**
     * Retrieves the style for a specific row based on the given object and row index.
     *
     * @param mixed $objObject The object associated with the row.
     * @param int $intRowIndex The index of the row to retrieve the style for.
     * @return null The style for the row, or null if not applicable.
     */
    protected function getRowStyle(mixed $objObject, int $intRowIndex): null
    {
        return null;
    }

    /**
     * Determines the CSS class to be applied to a row based on its index and object data.
     *
     * @param mixed $objObject The object associated with the row.
     * @param int $intRowIndex The index of the row.
     * @return string|null The CSS class for the row if defined, or null if no class is applicable.
     */
    protected function getRowClass(mixed $objObject, int $intRowIndex): ?string
    {
        if (($intRowIndex % 2) == 1 && $this->strAlternateRowCssClass) {
            return $this->strAlternateRowCssClass;
        } else {
            if ($this->strRowCssClass) {
                return $this->strRowCssClass;
            } else {
                return null;
            }
        }
    }

    /**
     * Generates the HTML for the footer row.
     *
     * @return string|null The HTML for the footer row, or null if not applicable.
     */
    protected function getFooterRowHtml(): ?string
    {
        return '';
    }

    /**
     * Generates the HTML for column tags, including only visible columns.
     *
     * @return string The generated HTML for all visible column tags.
     */
    protected function getColumnTagsHtml(): string
    {
        $strToReturn = '';
        $len = count($this->objColumnArray);
        $i = 0;
        while ($i < $len) {
            $objColumn = $this->objColumnArray[$i];
            if ($objColumn->Visible) {
                $strToReturn .= $objColumn->renderColTag() . _nl();
            }
            $i += $objColumn->Span;
        }
        return $strToReturn;
    }

    /**
     * Renders the caption HTML for the element if a caption is set.
     *
     * @return string The rendered caption HTML or an empty string if no caption is set.
     */
    protected function renderCaption(): string
    {
        $strHtml = '';
        if ($this->strCaption) {
            $strHtml .= '<caption>' . QString::htmlEntities($this->strCaption) . '</caption>' . _nl();
        }
        return $strHtml;
    }

    /**
     * Generates and returns the HTML for the control, including the table structure, headers, footers, and data rows.
     *
     * The method binds the data source, processes column tags, header, and footer rows if enabled,
     * and iterates over the data source to render rows in the table body. If the data source is empty
     * and hiding the control when empty is enabled, it returns an empty string.
     *
     * @return string The complete HTML string for the control, or an empty string if the data source is empty and hiding is enabled.
     * @throws Caller
     */
    protected function getControlHtml(): string
    {
        $this->dataBind();

        if (empty($this->objDataSource) && $this->blnHideIfEmpty) {
            $this->objDataSource = [];
            return '';
        }

        $strHtml = $this->renderCaption();

        // Column tags (if applicable)
        if ($this->blnRenderColumnTags) {
            $strHtml .= $this->getColumnTagsHtml();
        }

        // Header Row (if applicable)
        if ($this->blnShowHeader) {
            $strHtml .= Html::renderTag('thead', null, $this->getHeaderRowHtml());
        }

        // Footer Row (if applicable)
        if ($this->blnShowFooter) {
            $strHtml .= Html::renderTag('tfoot', null, $this->getFooterRowHtml());
        }

        // DataGrid Rows
        $strRows = '';
        $this->intCurrentRowIndex = 0;
        if ($this->objDataSource) {
            foreach ($this->objDataSource as $objObject) {
                $strRows .= $this->getDataGridRowHtml($objObject, $this->intCurrentRowIndex);
                $this->intCurrentRowIndex++;
            }
        }
        $strHtml .= Html::renderTag('tbody', null, $strRows);

        $strHtml = $this->renderTag('table', null, null, $strHtml);

        $this->objDataSource = [];

        return $strHtml;
    }

    /**
     * Prepares the object for serialization by putting its properties into a restorable state.
     *
     * @return array Returns an array of properties that should be serialized.
     */
    public function sleep(): array
    {
        if ($this->objColumnArray) {
            foreach ($this->objColumnArray as $objColumn) {
                $objColumn->sleep();
            }
        }
        $this->rowParamsCallback = Q\Project\Control\ControlBase::sleepHelper($this->rowParamsCallback);

        return parent::sleep();
    }

    /**
     * Restores the state of the object during the wakeup process and adjusts associated components accordingly.
     *
     * @param FormBase $objForm The form instance used during the wakeup process.
     * @return void
     */
    public function wakeup(FormBase $objForm): void
    {
        parent::wakeup($objForm);
        $this->rowParamsCallback = Q\Project\Control\ControlBase::wakeupHelper($objForm, $this->rowParamsCallback);
        if ($this->objColumnArray) {
            foreach ($this->objColumnArray as $objColumn) {
                $objColumn->wakeup($objForm);
            }
        }
    }

    /**
     * Magic method to get the value of a property by name.
     *
     * @param string $strName The name of the property to retrieve.
     * @return mixed The value of the specified property, or the value from the parent class's __get if the property is not found.
     * @throws Caller If the property does not exist and cannot be retrieved by the parent class.
     */
    public function __get(string $strName): mixed
    {
        switch ($strName) {
            case 'RowCssClass':
                return $this->strRowCssClass;
            case 'AlternateRowCssClass':
                return $this->strAlternateRowCssClass;
            case 'HeaderRowCssClass':
                return $this->strHeaderRowCssClass;
            case 'ShowHeader':
                return $this->blnShowHeader;
            case 'ShowFooter':
                return $this->blnShowFooter;
            case 'RenderColumnTags':
                return $this->blnRenderColumnTags;
            case 'Caption':
                return $this->strCaption;
            case 'HeaderRowCount':
                return $this->intHeaderRowCount;
            case 'CurrentHeaderRowIndex':
                return $this->intCurrentHeaderRowIndex;
            case 'HideIfEmpty':
                return $this->blnHideIfEmpty;
            case 'CurrentRowIndex':
                return $this->intCurrentRowIndex;

            default:
                try {
                    return parent::__get($strName);
                } catch (Caller $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }
        }
    }

    /**
     * Sets the value of a given property based on its name.
     *
     * @param string $strName The name of the property to set.
     * @param mixed $mixValue The value to assign to the property. The value's type will be validated and cast as needed.
     * @return void
     * @throws Caller
     * @throws InvalidCast
     * @throws Throwable
     */
    public function __set(string $strName, mixed $mixValue): void
    {
        switch ($strName) {
            case "RowCssClass":
                try {
                    $this->strRowCssClass = Type::cast($mixValue, Type::STRING);
                    break;
                } catch (InvalidCast $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }

            case "AlternateRowCssClass":
                try {
                    $this->strAlternateRowCssClass = Type::cast($mixValue, Type::STRING);
                    break;
                } catch (InvalidCast $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }

            case "HeaderRowCssClass":
                try {
                    $this->strHeaderRowCssClass = Type::cast($mixValue, Type::STRING);
                    break;
                } catch (InvalidCast $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }

            case "ShowHeader":
                try {
                    $this->blnShowHeader = Type::cast($mixValue, Type::BOOLEAN);
                    break;
                } catch (InvalidCast $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }

            case "ShowFooter":
                try {
                    $this->blnShowFooter = Type::cast($mixValue, Type::BOOLEAN);
                    break;
                } catch (InvalidCast $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }

            case "RenderColumnTags":
                try {
                    $this->blnRenderColumnTags = Type::cast($mixValue, Type::BOOLEAN);
                    break;
                } catch (InvalidCast $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }

            case "Caption":
                try {
                    $this->strCaption = Type::cast($mixValue, Type::STRING);
                    break;
                } catch (InvalidCast $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }

            case "HeaderRowCount":
                try {
                    $this->intHeaderRowCount = Type::cast($mixValue, Type::INTEGER);
                    break;
                } catch (InvalidCast $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }

            case "HideIfEmpty":
                try {
                    $this->blnHideIfEmpty = Type::cast($mixValue, Type::BOOLEAN);
                    break;
                } catch (InvalidCast $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }

            case "RowParamsCallback":
                try {
                    $this->rowParamsCallback = Type::cast($mixValue, Type::CALLABLE_TYPE);
                    break;
                } catch (InvalidCast $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }


            default:
                try {
                    parent::__set($strName, $mixValue);
                    break;
                } catch (Caller $objExc) {
                    $objExc->incrementOffset();
                    throw $objExc;
                }
        }
    }

    /**
     * Retrieves the parameters used for configuring the model connector.
     *
     * @return array An array of parameters, including inherited and specific options such as CSS classes for rows,
     * header and footer visibility, rendering column tags, table caption, and behavior when data is empty.
     * @throws Caller
     */
    public static function getModelConnectorParams(): array
    {
        return array_merge(parent::getModelConnectorParams(), array(
            new Q\ModelConnector\Param(get_called_class(), 'RowCssClass', 'CSS class given to each row',
                Type::STRING),
            new Q\ModelConnector\Param(get_called_class(), 'AlternateRowCssClass', 'CSS class given to every other row',
                Type::STRING),
            new Q\ModelConnector\Param(get_called_class(), 'HeaderRowCssClass', 'CSS class given to the header rows',
                Type::STRING),
            new Q\ModelConnector\Param(get_called_class(), 'ShowHeader',
                'Whether or not to show the header. Default is true.', Type::BOOLEAN),
            new Q\ModelConnector\Param(get_called_class(), 'ShowFooter',
                'Whether or not to show the footer. Default is false.', Type::BOOLEAN),
            new Q\ModelConnector\Param(get_called_class(), 'RenderColumnTags',
                'Whether or not to render HTML column tags for the columns. Column tags are only needed in special situations. Default is false.',
                Type::BOOLEAN),
            new Q\ModelConnector\Param(get_called_class(), 'Caption', 'Text to print in the caption tag of the table.',
                Type::STRING),
            new Q\ModelConnector\Param(get_called_class(), 'HideIfEmpty',
                'Whether to draw nothing if there is no data, or draw the table tags with no cells instead. The default is to drag the table tags.',
                Type::BOOLEAN)
        ));
    }
}
